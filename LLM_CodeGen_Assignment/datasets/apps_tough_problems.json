{
  "dataset_name": "APPS_TOUGH_PROBLEMS",
  "description": "Selected challenging problems from the APPS dataset for advanced code generation evaluation. These problems require more complex algorithmic thinking and implementation skills.",
  "problems": [
    {
      "task_id": "APPS/0",
      "difficulty": "Hard",
      "source": "APPS Dataset - Competitive Programming",
      "title": "Knapsack Variant",
      "prompt": "def solve_knapsack_variant(n, w, k, items):\n    '''\n    You are given N items, each with a weight w[i] and value v[i].\n    You have a knapsack with capacity W.\n    However, there's a twist: you can take at most K items of each type.\n    \n    Find the maximum value you can achieve.\n    \n    Parameters:\n    - n: number of item types\n    - w: knapsack capacity  \n    - k: max items per type\n    - items: list of (weight, value) tuples\n    \n    Example:\n    n=3, w=10, k=2\n    items=[(2,3), (3,4), (4,5)]\n    \n    You can take at most 2 of each item type.\n    Optimal: Take 2 items of type 1 (weight=4, value=6) and 2 items of type 2 (weight=6, value=8)\n    Total: weight=10, value=14\n    \n    Return the maximum value achievable.\n    '''",
      "test": "def test_knapsack_variant():\n    # Test case 1: Basic example\n    # N=3, W=10, K=2, items=[(2,3), (3,4), (4,5)]\n    result = solve_knapsack_variant(3, 10, 2, [(2,3), (3,4), (4,5)])\n    assert result == 14, f\"Expected 14, got {result}\"\n    \n    # Test case 2: All items fit\n    # N=2, W=20, K=3, items=[(2,5), (3,7)]\n    result = solve_knapsack_variant(2, 20, 3, [(2,5), (3,7)])\n    assert result == 36, f\"Expected 36, got {result}\"  # 3*5 + 3*7 = 36\n    \n    # Test case 3: Single item type\n    result = solve_knapsack_variant(1, 5, 2, [(3,4)])\n    assert result == 4, f\"Expected 4, got {result}\"  # Can take 1 item\n    \n    print(\"All knapsack tests passed!\")\n\ntest_knapsack_variant()",
      "test_cases": [
        {
          "input": {"n": 3, "w": 10, "k": 2, "items": [[2,3], [3,4], [4,5]]},
          "expected_output": 14,
          "description": "Basic example with 3 item types"
        },
        {
          "input": {"n": 2, "w": 20, "k": 3, "items": [[2,5], [3,7]]},
          "expected_output": 36,
          "description": "All items fit in knapsack"
        },
        {
          "input": {"n": 1, "w": 5, "k": 2, "items": [[3,4]]},
          "expected_output": 4,
          "description": "Single item type"
        }
      ]
    },
    {
      "task_id": "APPS/1",
      "difficulty": "Hard",
      "source": "APPS Dataset - Graph Algorithms",
      "title": "Shortest Path with Obstacles",
      "prompt": "def shortest_path_with_obstacles(grid, k):\n    '''\n    You are given a grid of size N x M where:\n    - 0 represents an empty cell\n    - 1 represents an obstacle\n    - 2 represents the start position\n    - 3 represents the end position\n    \n    You can move in 4 directions (up, down, left, right).\n    However, you have a special ability: you can remove at most K obstacles during your journey.\n    \n    Find the shortest path from start to end, considering you can remove at most K obstacles.\n    Return the minimum number of steps, or -1 if impossible.\n    \n    Parameters:\n    - grid: 2D list representing the grid\n    - k: maximum number of obstacles you can remove\n    \n    Example:\n    grid = [[2, 1, 0, 0],\n            [0, 1, 1, 0], \n            [0, 0, 1, 3]]\n    k = 1\n    \n    Without removing obstacles: impossible\n    With removing 1 obstacle: can reach in 5 steps\n    '''",
      "test": "def test_shortest_path():\n    # Test case 1: Basic example\n    grid1 = [\n        [2, 1, 0, 0],\n        [0, 1, 1, 0], \n        [0, 0, 1, 3]\n    ]\n    result = shortest_path_with_obstacles(grid1, 1)\n    assert result == 5, f\"Expected 5, got {result}\"\n    \n    # Test case 2: No obstacles needed to remove\n    grid2 = [\n        [2, 0, 0],\n        [0, 0, 0],\n        [0, 0, 3]\n    ]\n    result = shortest_path_with_obstacles(grid2, 0)\n    assert result == 4, f\"Expected 4, got {result}\"\n    \n    # Test case 3: Impossible even with K removals\n    grid3 = [\n        [2, 1, 1],\n        [1, 1, 1],\n        [1, 1, 3]\n    ]\n    result = shortest_path_with_obstacles(grid3, 1)\n    assert result == -1, f\"Expected -1, got {result}\"\n    \n    print(\"All shortest path tests passed!\")\n\ntest_shortest_path()",
      "test_cases": [
        {
          "input": {"grid": [[2, 1, 0, 0], [0, 1, 1, 0], [0, 0, 1, 3]], "k": 1},
          "expected_output": 5,
          "description": "Basic example requiring 1 obstacle removal"
        },
        {
          "input": {"grid": [[2, 0, 0], [0, 0, 0], [0, 0, 3]], "k": 0},
          "expected_output": 4,
          "description": "No obstacles to remove"
        },
        {
          "input": {"grid": [[2, 1, 1], [1, 1, 1], [1, 1, 3]], "k": 1},
          "expected_output": -1,
          "description": "Impossible even with removals"
        }
      ]
    },
    {
      "task_id": "APPS/2",
      "difficulty": "Hard",
      "source": "APPS Dataset - Dynamic Programming",
      "title": "Valid Parentheses Sequences",
      "prompt": "def count_valid_parentheses_sequences(s):\n    '''\n    Given a string containing '(', ')', and '?', where '?' can be either '(' or ')'.\n    Count the number of ways to replace '?' characters such that the resulting string\n    has valid parentheses.\n    \n    A valid parentheses string is one where:\n    1. Every '(' has a matching ')'\n    2. At no point do we have more ')' than '(' when reading left to right\n    \n    Return the count modulo 10^9 + 7.\n    \n    Parameters:\n    - s: string containing '(', ')', and '?' characters\n    \n    Examples:\n    \"(?)\" -> 1 way: \"()\"\n    \"(??)\" -> 1 way: \"(())\"\n    \"????\" -> 2 ways: \"(())\" and \"()()\"\n    '''",
      "test": "def test_parentheses_count():\n    # Test case 1: Simple case\n    result = count_valid_parentheses_sequences(\"(?)\")\n    assert result == 1, f\"Expected 1, got {result}\"\n    \n    # Test case 2: Multiple possibilities\n    result = count_valid_parentheses_sequences(\"????\")\n    assert result == 2, f\"Expected 2, got {result}\"\n    \n    # Test case 3: Fixed parentheses\n    result = count_valid_parentheses_sequences(\"(())\")\n    assert result == 1, f\"Expected 1, got {result}\"\n    \n    # Test case 4: Impossible case\n    result = count_valid_parentheses_sequences(\"(((\")\n    assert result == 0, f\"Expected 0, got {result}\"\n    \n    print(\"All parentheses count tests passed!\")\n\ntest_parentheses_count()",
      "test_cases": [
        {
          "input": {"s": "(?)"},
          "expected_output": 1,
          "description": "Simple case with one wildcard"
        },
        {
          "input": {"s": "????"},
          "expected_output": 2,
          "description": "Multiple wildcards with 2 valid arrangements"
        },
        {
          "input": {"s": "(())"},
          "expected_output": 1,
          "description": "Fixed valid parentheses"
        },
        {
          "input": {"s": "((("},
          "expected_output": 0,
          "description": "Impossible case"
        }
      ]
    },
    {
      "task_id": "APPS/3",
      "difficulty": "Hard",
      "source": "APPS Dataset - Number Theory",
      "title": "Divisible Subarrays",
      "prompt": "def count_divisible_subarrays(arr, k):\n    '''\n    Given an array of integers and a number K, count the number of subarrays\n    whose sum is divisible by K.\n    \n    A subarray is a contiguous part of an array.\n    \n    Use modular arithmetic properties:\n    If (prefix_sum[j] - prefix_sum[i]) % K == 0, then prefix_sum[j] % K == prefix_sum[i] % K\n    \n    Parameters:\n    - arr: list of integers\n    - k: divisor\n    \n    Examples:\n    arr = [4, 5, 0, -2, -3, 1], k = 5\n    Subarrays with sum divisible by 5:\n    [5], [5, 0], [5, 0, -2, -3], [0], [-2, -3], [4, 5, 0, -2, -3, 1]\n    Answer: 7\n    '''",
      "test": "def test_divisible_subarrays():\n    # Test case 1: Basic example\n    arr1 = [4, 5, 0, -2, -3, 1]\n    result = count_divisible_subarrays(arr1, 5)\n    assert result == 7, f\"Expected 7, got {result}\"\n    \n    # Test case 2: All elements divisible\n    arr2 = [2, 4, 6]\n    result = count_divisible_subarrays(arr2, 2)\n    assert result == 6, f\"Expected 6, got {result}\"  # All subarrays\n    \n    # Test case 3: No divisible subarrays except individual elements\n    arr3 = [1, 2, 3]\n    result = count_divisible_subarrays(arr3, 7)\n    assert result == 0, f\"Expected 0, got {result}\"\n    \n    print(\"All divisible subarrays tests passed!\")\n\ntest_divisible_subarrays()",
      "test_cases": [
        {
          "input": {"arr": [4, 5, 0, -2, -3, 1], "k": 5},
          "expected_output": 7,
          "description": "Basic example with multiple divisible subarrays"
        },
        {
          "input": {"arr": [2, 4, 6], "k": 2},
          "expected_output": 6,
          "description": "All elements divisible by k"
        },
        {
          "input": {"arr": [1, 2, 3], "k": 7},
          "expected_output": 0,
          "description": "No divisible subarrays"
        }
      ]
    },
    {
      "task_id": "APPS/4",
      "difficulty": "Hard",
      "source": "APPS Dataset - Tree Algorithms",
      "title": "Tree Diameter with Weights",
      "prompt": "def tree_diameter_with_weights(edges, n):\n    '''\n    Given a weighted tree (connected acyclic graph), find the diameter.\n    The diameter is the longest path between any two nodes in the tree.\n    \n    Parameters:\n    - edges: list of tuples (u, v, weight) representing edges\n    - n: number of nodes (nodes are numbered 0 to n-1)\n    \n    Algorithm approach:\n    1. Pick any node, find the farthest node from it (using DFS/BFS)\n    2. From that farthest node, find the farthest node again\n    3. The distance in step 2 is the diameter\n    \n    Example:\n    edges = [(0, 1, 5), (1, 2, 3), (2, 3, 7)]\n    Tree: 0--(5)--1--(3)--2--(7)--3\n    Diameter = 5 + 3 + 7 = 15\n    '''",
      "test": "def test_tree_diameter():\n    # Test case 1: Linear tree\n    edges1 = [(0, 1, 5), (1, 2, 3), (2, 3, 7)]\n    result = tree_diameter_with_weights(edges1, 4)\n    assert result == 15, f\"Expected 15, got {result}\"\n    \n    # Test case 2: Star tree\n    edges2 = [(0, 1, 2), (0, 2, 3), (0, 3, 4)]\n    result = tree_diameter_with_weights(edges2, 4)\n    assert result == 7, f\"Expected 7, got {result}\"  # 3 + 4\n    \n    # Test case 3: Single edge\n    edges3 = [(0, 1, 10)]\n    result = tree_diameter_with_weights(edges3, 2)\n    assert result == 10, f\"Expected 10, got {result}\"\n    \n    print(\"All tree diameter tests passed!\")\n\ntest_tree_diameter()",
      "test_cases": [
        {
          "input": {"edges": [[0, 1, 5], [1, 2, 3], [2, 3, 7]], "n": 4},
          "expected_output": 15,
          "description": "Linear tree with 4 nodes"
        },
        {
          "input": {"edges": [[0, 1, 2], [0, 2, 3], [0, 3, 4]], "n": 4},
          "expected_output": 7,
          "description": "Star tree with center at node 0"
        },
        {
          "input": {"edges": [[0, 1, 10]], "n": 2},
          "expected_output": 10,
          "description": "Simple tree with single edge"
        }
      ]
    }
  ],
  "metadata": {
    "total_problems": 5,
    "difficulty_distribution": {
      "Hard": 5
    },
    "algorithm_categories": [
      "Dynamic Programming",
      "Graph Algorithms", 
      "Number Theory",
      "Tree Algorithms",
      "Competitive Programming"
    ],
    "created_date": "2024-11-05",
    "format_version": "1.0"
  }
}